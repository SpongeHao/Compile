大家日常编程中估计多多少少都接触过正则表达式，用它来匹配字符串等，也可能已经很熟悉其语法了。但我这次想从正则表达式的最基本概念来重新介绍一次，主要想让大家更深地理解它。首先我们要重新定义一下“语言”这个概念。“语言”就是指字符串的集合，其中的字符来自于一个有限的字符集合。也就是说，语言总要定义在一个有限的字符集上，但是语言本身可以既可以是有穷集合，也可以是无穷集合。比如“C#语言”就是指满足C#语法的全体字符串的集合，它显然是个无穷集合。当然也可以定义一些简单的语言，比如这个语言{ a }就只有一个成员，那就是一个字母a。后面我们都用大括号{}来表示字符串的集合。所谓正则表达式呢，就是描述一类语言的一种特殊表达式，正则表达式共有2种基本要素：

表达式ε表示一个语言，仅包含一个长度为零的字符串，可以理解为{ String.Empty }，我们通常把String.Empty记作ε，读作epsilon。
对字符集中任意字符a，表达式a表示仅有一个字符a的语言，即{ a }。
同时正则表达式定义了3种基本运算规则：

两个正则表达式的并，记作X|Y，表示的语言是正则表达式X所表示的语言与正则表达式Y所表示语言的并集。比如a|b所得的语言就是{a, b}。类似于加法
两个正则表达式的连接，记作XY，表示的语言是将X的语言中每个字符串后面连接上Y语言中的每一种字符串，再把所有这种连接的结果组成一种新的语言。比如令X = a|b，Y = c|d，那么XY所表示的语言就是{ac, bc, ad, bd}。因为X表示是{a, b}，而Y表示的是{ c, d}，连接运算取X语言的每一个字符串接上Y语言的每一个字符串，最后得到了4种连接结果。这类似于乘法
一个正则表达式的克林闭包，记作X*，表示分别将零个，一个，两个……无穷个X与自己连接，然后再把所有这些求并。也就是说X* = ε | X | XX | XXX | XXX | ……。比如a*这个正则表达式，就表示的是个无穷语言{ ε, a, aa, aaa, aaaa, …. }。这相当于任意次重复一个语言。
以上三种运算写在一起时克林闭包的优先级高于连接运算，而连接运算的优先级高于并运算。以上就是正则表达式的全部规则！并不是很难理解对吧？下面我们用正则表达式来描述一下刚才各个词素的规则。

 

首先是关键字string，刚才我们描述说它是“正好是s-t-r-i-n-g这几个字母按顺序组成”，用正则表达式来表示，那就是s-t-r-i-n-g这几个字母的连接运算，所以写成正则表达是就是string。大家一定会觉得这个例子很无聊。。那么我们来看下一个例子：标识符。用白话来描述是“由字母开头，后面可以跟零个或多个字母或数字”。先用正则表达式描述“由字母开头”，那就是指，可以是a-z中任意一个字母来开头。这是正则表达式中的并运算：a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z。如果每个正则表达式都这么写，那真是要疯掉了，所以我们引入方括号语法，写在方括号里就表示这些字符的并运算。比如[abc]就表示a|b|c。而a-z一共26个字母我们也简写成a-z，这样，“由字母开头”就可以翻译成正则表达式[a-z]了。接下来我们翻译第二句“后面可以跟零个或多个字母或数字”这句话中的“零个或多个”可以翻译成克林闭包运算，最后相信大家都可以写出来，就是[a-z0-9]*。最后，前后两句之间是一个连接运算，因此最后描述标识符“语言”的正则表达式就是[a-z][a-z0-9]*。其中的*运算也意味着“标识符”是一种无穷语言，有无数种可能的标识符。本来就是这样，很好理解对吧？

 

从上面例子可以看出，正则表达式都可以用两种要素和三种基本运算组合出来。但是如果我们要真的拿来描述词法单词的规则，需要一些便于使用的辅助语法，就像上边的方括号语法那样。我们定义一些正则表达式的扩展运算：

方括号表示括号内的字符并运算。[abc]就等于a|b|c
方括号中以^字符开头，表示字符集中，排除方括号中的所有字符之后，所剩字符的并运算。[^ab]就表示除了ab以外所有字符求并。
圆.点表示字符集内所有字符的并。因此 .* 这个表达式就能表示这种字符集所能组成的一切字符串。
X?表示 X|ε 。表示X与空字符串之间可选。
X+表示XX*。这等于限制了X至少要重复1次。
